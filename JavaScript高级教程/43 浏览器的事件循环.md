# 浏览器的事件循环

问：浏览器是一个进程吗？它内部只有一个线程吗？

- 目前多数的浏览器其实都是多进程的，当我们打开一个tab页面就会开启一个新的进程，这是为了防止一个页面卡死而造成所有的页面无法响应，整个浏览器都需要强制退出；
- 每个进程中又有很多的线程，其中包括执行JavaScript代码的线程；



JavaScript代码执行是在一个单独的线程中执行的：

- 这就意味着，==JavaScript的代码在同一时刻只能做一件事==；
- ==如果这件事非常的耗时，就意味着当前的线程会被阻塞==；



所以一些真正耗时的操作，实际上并不是由JavaScript线程在执行的：

- 浏览器的每个进程是多线程的，那么其他线程也可以来完成这个耗时的操作；
- 比如网络请求，定时器，我们只需要在结果的时候执行应该有的回调就可以；



也就是说，如果JavaScript再执行过程中发现了异步操作时：

- 会将异步的操作放入一个调用栈中，执行会立即结束，并不会阻塞后续代码的执行。



# 单线程-微任务-宏任务的区别

事件循环中并非只维护着一个队列，事实上是有两个队列：

- ==宏任务队列==：ajax，计时器，DOM监听，UI Readering等；
- ==微任务队列==：Promise的回调，Mutation Obkserver API，queueMicrotask等；

在执行任何一个红宏任务之前（不是队列，是一个宏任务），都会查看微任务队列中是否有任务需要执行：

- 也就是宏任务执行之前，必须保证微任务队列是空的；
- 如果不是空，那么就有限执行微任务队列中的人物（回调）；



javaScript 是一种单线程的语言，单线程和事件循环密切相关。

- 单线程：在同一时间内只能处理一个任务，处理完其一才能处理下一个。之所以 JavaScript 是单线程，一方面是历史原因：JavaScript 诞生时主要用途是处理简单的计算、操作 DOM，不需要更复杂的功能。另一方面，JavaScript 语言的主要用途是与用户互动，以及操作 DOM，这决定了它只能有一个执行线程，否则会带来很复杂的同步问题。
- 事件循环(Event Loop)：为了协调事件、用户交互、脚本执行、渲染、网络等，JavaScript 引擎使用了事件循环模型。事件循环是指浏览器或 Node 的一种实现，它取出任务队列中的任务，一次执行一个，直到队列清空。然后再去看有没有微任务需要执行，有的话就一次执行完所有微任务，如果此时任务队列中又有新的任务就再取出来执行，如此循环。
- 宏任务(macrotask) 和微任务(microtask)：JavaScript 引入了宏任务机制，许多任务例如：包括脚本全文执行、setTimeout，setInterval，setImmediate(Node.js 环境) 和 I/O、UI渲染等。这种宏任务会被推入任务队列，等待前面的任务执行完毕后才会执行。同时，也引入了微任务机制，例如 Promise.then，MutationObserver，process.nextTick(Node.js 环境)等，这些微任务会在当前任务（也就是宏任务）的末尾执行，如果在微任务执行时又产生了新的微任务，那么新的微任务也会在当前任务末尾执行，直到所有的微任务执行完成。

执行顺序是：首先执行唯一的宏任务（全局脚本代码），在此过程中产生的宏任务和微任务分别进入各自队列，然后一次清空微任务队列（即执行所有微任务，可能执行过程中产生新的微任务），微任务队列清空后再去宏任务队列中取出一个事件执行，执行完后再执行其产生的微任务，然后再取宏任务，如此循环，形成了我们的事件循环机制。