# JavaScript内存管理

## 什么是内存管理？

无论是什么编程语言，==在代码执行过程中都是需要分配给它分配内存的==，不同的是某些编程语言需要我们自己手动的管理内存（比如C，C++），某些编程语言会自动帮我们管理内存（比如JVMJava虚拟机，比如V8引擎）。

不管是什么样的方式来管理内存，内存的管理都会有如下的**生命周期**：

1. 第一步：分配==申请==你需要的内存（申请）；
2. 第二步：==使用==分配的内存（存放一些内容，比如对象等）；
3. 第三步：不需要使用时，对其进行==释放==；

JavaScript会在定义数据的时候为我们分配内存，对于**原始数据类型内存**的分配会在执行的时候直接在栈内存中进行分配；对于**复杂数据类型内存**的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用。



# JavaScript垃圾回收

因为内存大小是有限的，所以当内存不再需要的时候，我们需要对其进行释放已腾出更多内存空间。

因为手动管理内存的语言的管理方式非常低效，影响代码编写效率，并且对开发者要求也很高，一不小心就会产生内存泄露。

所以大部分现代的编程语言都有自己的垃圾回收机制，**对于那些不在使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间**。

而语言的运行环境，比如Java的JVM和JavaScript引擎都会内存==垃圾回收器==，垃圾回收器简称为==GC==。



## 常见的GC算法：标记清除（mark Sweep）

标记清除的核心思路是==可达性==。

这个算法是**设置一个根对象（Root Object），垃圾回收期会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象就是不可用的对象**。

这个算法可以很好的解决循环引用的问题。

在JavaScript中，这个对象就是window对象。

**标记清除在逻辑上是一个图结构而不是一个树结构，因为后面的对象也可以引用前面的元素**。



## 常见GC算法：其他算法补充

1. **标记整理**（Mark Compack）：这个算法和标记清楚算法相似，但不同的地点在于，回收期间会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化。
2. **分带收集**（Generational collection)：对象被分为两组，分别是==“旧的”==和==“新的”==，许多对象出现，完成他们的工作并很快的死去，它们可以被很快清理，那些长期存活的对象会变的老旧，而且被检查的频次也会被减少。
3.  **增量收集**（Incremental collection）：如果有许多对象，并且试图一次遍历并标记整个对象集，则可能需要一些时间，在执行过程中带来明显的延迟，所以引擎试图将垃圾搜集工作分为几部分来做，然后将几部分进行逐一处理，这样会有很多微小的延迟而不是一个大的延迟。
4. **闲时收集**：垃圾收集器只会在CPU空闲时尝试运行，以减少可能对代码执行的影响。



# 闭包！

下面这段引言摘抄自《你不了解的JavaScript》：

> 对于那些有一些理解JavaScript使用经验但是从未真正理解闭包概念的人来说，理解闭包可以看做是某种意义上的重生，但是需要付出非常多的努力和牺牲才能理解这个概念。
>
> 回忆我前几年的时光，大量使用JavaScript但却完全不理解闭包是什么，总感觉这门语言有其隐蔽的一面，如果能掌握将会功力大涨，但嘲讽的是我始终无法掌握其中的门道，还记得我曾将大量阅读早起框架的远吗，试图能够理解闭包的工作原理。现在还能回忆起在我脑海里第一次浮现出“模块模式”相关概念时的激动心情。

首先在了解闭包之前，要知道JavaScript支持==函数式编程==。

函数非常重要，是JavaScript中的头等公民！它的使用非常灵活，可以作为函数的参数也可以作为另一个函数的返回值。



## 闭包的定义

闭包的定义可以分为两个，一个是在==计算机科学中==，一个是在==JavaScript中==。

在计算机科学中：

- 闭包又叫做调法闭包或者函数闭包。
- 是在支持头等函数的编程语言中，实现词法绑定的一种技术。
- 闭包在实现上是一个结构体，它存储了==一个函数==和==一个关联的环境==（相当于一个符号查找表）。
- 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确认，这样及时脱离了捕捉时的上下文，它也能照常运行。

以上是官方文档的解释，通俗点来讲（用例子说明）：

```JavaScript
function fun() {
	// 代码块
}
```

闭包可以理解为函数和它所在的环境，在上面这个代码中，==**闭包就是这个函数和他所在的作用域链（环境）**==，这两个东西一起组成的结构就是闭包。



闭包在JavaScript中的解释：

- 一个函数和对其周围状态（lexical environment，调法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）；
- **也就是说闭包可以让你在一个内层函数中访问到其外层函数的作用域**；
- 在JavaScript中，每当创建一个函数，**闭包就会在函数创建的同时被创建出来**。



如果没有闭包，代码会变成什么样子？

```JavaScript
var name = "meiciko"
var age = 18
var height = 1.88
... ...
var address = "AWL"

function fun() {
  console.log(name, age, height, ... , address)
  // 正常情况下，这个函数是可以访问name到address这些变量的。
  // 但是这是JavaScript做出的优化，是闭包带来的好处。
}

// 如果没有闭包，代码想要完成上述效果是如下方式书写的：
function fun(name, age, height, ... , address) {
  console.log(name, age, height, ... , address)
  // 如果没有闭包, 函数想要拿到外部的参数, 就需要做出上述的操作.
  // 非常麻烦而且不方便, 难以辨别.
}
```

==总之, 一个函数如果能够访问函数外部的自由变量, 那么这个函数和周围环境就是一个闭包! 广义来说, JavaScript的函数都是一个闭包.== 

==广义来说, JavaScript的函数都是闭包的;==

==狭义来说, JavaScript函数如果访问了外部的变量, 那么它就是一个闭包.==





## 闭包的访问过程

```JavaScript
// 深入闭包访问过程
function createAdder(count) {
  function adder(num) {
    return count + num
  }

  return adder
}

var adder5 = createAdder(5)
adder5(100)
```

当adder函数被创建的那一刻, 它会确定它和周围的环境, 形成闭包, 而在它的闭包中, 可以找到count的.

1. 在这段代码执行之前, 会初始化一个GO对象, GO对象中有初始化的adder5, 并且初始化了createAdder方法, createAdde方法中有一个作用域链对象, 这个对象被赋值给一个地址, 所对应的地址的对象中的作用域链列表第一位就是GO
2. 当开始执行的时候, 创建一个执行上下文, 然后开始执行第十行的代码, 这行代码中有对函数的调用, 所以此时会在执行上下文栈中再创建一个执行上下文, 这个执行上下文会关联一个AO对象, 并在执行函数内部代码前先初始化adder方法, add方法有一些初始的属性和一个作用域属性, 这个作用域属性是一个列表对象的地址, 里面的作用域链列表第一位是createAdder方法对应的AO, 然后是GO.
3. 开始执行, 会将函数createAdder中的count赋值给5, 将函数adder的地址赋值给GO中的adder5.
4. 弹出执行上下文, 执行上下文栈中最上层的变为全局执行上下文.
5. 执行地11行, 创建执行上下文, 和它关联的AO, 此时AO中有num和argument等等, 然后开始执行代码, 执行num的赋值操作, num值变为100,  然后执行 count + num , 寻找count, 但是本身没有count, 于是在作用域链中寻找, 发现在createAdder对应的AO中是有count的, 即5, 然后执行count + num.
6. 第11行执行完成, 所对应的执行上下文弹出.

## 闭包的内存泄露

以上述代码为例，因为adder5等等可能还会用到，所以不存在内存泄漏，但是如果在接下来某一行之后，我永远不会在用到它了，但是一般是不管的，又因为可达性的算法，这部分内存是不会被释放的，这时候就会存在内存泄漏。

**所以，对于那些永远不会再使用的对象，但是对于GC来说，它不知道要进行释放的内存之后会不会用到（虽然人知道），依然会保留，这种情况会造成泄漏的**。

==此时，我们需要手动的来给他释放==。

想要释放内存的方法也很简单：

```javascript
adder5 = null 
```

在执行这句后，GC再次运行的时候，会发现关于adder的对象没有被引用了，**没有了可达性**，于是会将它回收掉！

所以这个时候，手动释放内存是很重要的。



### 深入闭包 -- 浏览器的优化操作

先看下面这段代码：

```JavaScript
function fun() {
  var name = "meiciko"
  var age = 18
  var address = "HB"
  
  function foo() {
    console.log(name, address)
  }
  
  return foo
}

var f = fun()
f()
```

在上述代码中，fun的AO因为会被引用，而不会被GC清除，但是其实fun中有一个属性并没有被使用到，即age。

理论上来说，age删掉也没有关系的，这时，浏览器其实就会对它做这些优化。

实际上，浏览器已经做了优化，age已经被释放掉了，age已经找不到了。